extern crate clap;
extern crate image;
extern crate gif;
extern crate tempfile;
extern crate rustc_serialize;
extern crate encoding;

use std::str;
use std::io::prelude::*;
use std::fs::File;
use serde_json::Value;
use std::iter::FromIterator;
use clap::{App, AppSettings, Arg};
use image::{DynamicImage, GenericImage};
use rustc_serialize::base64::FromBase64;
use encoding::{Encoding, DecoderTrap};
use encoding::all::UTF_8;

fn parse_timeline(path: &str) -> Value {
  let mut source = File::open(path).unwrap();
  let mut raw    = String::new();

  source.read_to_string(&mut raw).unwrap();
  let data: Value = serde_json::from_str(&raw).unwrap();
  data
}

struct Screenshot {
  decoded: DynamicImage,
}

impl Screenshot {
  pub fn new(data: &str) -> Option<Screenshot> {
    match Screenshot::str_to_img(data) {
      Some(img) => {
        Some(Screenshot { decoded: img })
      },
      None => { None }
    }
  }

  pub fn width(&self) -> u16 {
    self.decoded.width() as u16
  }

  pub fn height(&self) -> u16 {
    self.decoded.height() as u16
  }

  fn str_to_img(data: &str) -> Option<DynamicImage> {
    match data.from_base64() {
      Ok(bytes) => {
        match image::load_from_memory_with_format(&bytes[..],
                                                  image::ImageFormat::JPEG) {

          Ok(img) => { Some(img) },
          Err(reason) => {
            println!("{:?}", reason);
            None
          }
        }
      },
      Err(reason) => {
        println!("{:?}", reason);
        None
      },
    }
  }
}

fn parse_screenshot(candidate: &Value) -> Option<Screenshot> {
  match candidate.find("name") {
    Some(name) => match name.as_string() {
      Some("Screenshot") => {
        Screenshot::new(&candidate.lookup("args.snapshot")
                                  .unwrap()
                                  .as_string()
                                  .unwrap())
      },
      _ => None,
    },
    _ => None
  }
}

fn main() {
  let matches = App::new("timeline")
                      .version("0.1.0")
                      .author("Steven Sloan <stevenosloan@gmail.com")
                      .about("Generate a gif from Chrome timeline data")
                      .setting(AppSettings::ArgRequiredElseHelp)
                      .arg(Arg::with_name("input")
                                  .help("timeline file")
                                  .index(1)
                                  .required(true))
                      .arg(Arg::with_name("output")
                                  .help("output file (default is INPUT.gif")
                                  .takes_value(true)
                                  .short("o")
                                  .long("output"))
                      .get_matches();

  let input = matches.value_of("input").unwrap();
  println!("Doing real work with file: {}", input);

  let timeline = parse_timeline(input);
  let mut filtered = timeline.as_array()
                         .unwrap()
                         .iter()
                         .filter_map(|s| parse_screenshot(s));


  let mut done = false;
  while !done {
    match filtered.next() {
      Some(screen) => {
        println!("dimensions: {}x{}", screen.width(), screen.height());
      },
      None => { done = true; }
    }
  }
}
